#Composite Project

-Projects saved as single XML file, which makes it difficult to share among other testers, working on same project.
SEtting "Composite Project" to TRUE, the project is separated into multiple components.
-Environments can change endpoints, database connections, properties and more
-Event handlers can customize all aspects of API interactions/applies custom behavior to API calls

About XML
	Designed to store and Transport Data
	Has no Pre-Defined taga - tags are complete customizeable
	XML separates information from Presentation
	XML is Fundamental concept for Web Services 
About JSON
	Data Representation format - similar to XML
Used in SOAP services:
	XML	
	XML Schema
	XPath
	WSDL
Used in REST Services
	XML
	JSON 
	JSONPath
	HTTP Methods (GET, PUT, POST, DELETE)
Bonus skills:
	Regex
	Message Header
	URI
	SQL

#Architecture
Jasper / Saxon / Logging / H2 Database / JDBC Drives / HermesJMS / Monitoring / Runner / Jetty 

#Integration tab contains all the plug ins that readyapi offers. Some of them need side installation

#Projects
Project contains everything to test API 
Project is like a container 
Definitions are stored in XML file
Project don't contains data but it can be send via email
LoadUI offers comprehensive sets of predefined and configurable perfomance tests that are able to build upon functional tests already created in SoapUI 
Simulating soap/rest/JMS/jdbc apis = check out Service V pro 
Artifacts - They are primarily of interests of development
		Many software development tools build them by default
		End users have no interest in artifacts
Zephyr Intergration - design/manager/track tests 

Logging - Powered by log4j
	Records numerous logs:	
		ReadyAPI/HTTP/JETTY/Error/WS-RM/Script/LoadUI
	If experiencing some soft stack tracing - restart API software and it often clears off the problem
# Properties (TestStep) need to be above API calls (REST request/SOAP Request)
# Assertions - determine if readyapi is behaving according to your expectations and requirements 

Jetty - Java HTTP server and Java Servlet container. It is often used for machine to machine communications.
Jetty is Web Server which is know to be portable, lightweight, robust, flexible, extensible and easy to integrate. 
Jetty Web Server is foundational technology that makes it possible to create very realistic simulations of your api whether they in development or externally hosted. 
#H2 Database 

#Event Handlers
	SubmitListener - Take action before or after a requst is submitted
	RequestFilter - INtercept a request, and modify it
	ProjectRunListener - Determine when a project has been run
	TestSuiteRunListener - Listen for invocations of a given TestSuite, and take action
	TestRunListener - Listen for invocations of a given TestCase, take action
	LoadTestRunListener - Customize behavior during a load test
	MockRunListener - Intercepts calls to a mock service
	MonitorListener - Customize behavior for SOAP traffic monitoring
	SecurityTestRunListener - Customize behavior during a security scan
# Properties - may accessed via scripts and wizards
	property names are NOT case sensitive
	Property names may contain spaces
	Properties available in many levels:	
		Global/TestSuite, Virtual API, Project, Request, Virtial API response 
# Composite Project - with Setting "composite project" to True, the project is separated into multiple components 
	It is an option that let user to share project amont team members/coleagues 
	This lets team work on project at the same time
	
#Repository - GIT - Source Code Control Integration
	ReadyAPI includes built-in support for Git-based repositories such GitHub/GitLab/BitBucket
	Once project saved in Repository, user can fetch copy from repository if accidentally deleted
# Projects are stored in potentially large XML files
# Composite projects support multiple concurrent users
# Projects can be launched from command line or within the product
# Environment can change endpoints, database, connections, properties, etc.
 
#Manual API Interaction

Creating Project:
	Definition - point soapui endpoint Resource definition. SoapUI examines the resource and automatically determines 
		how to set up right project based on what you provided
		In Definition tab, Under "URL or File Path" user can paste SOAP live Web Service endpoint 
	Endpoint = create a project by providing one or more endpoints. This is for commonly if user wants to test Specific REST API
		Select specific method GET/POST/PUT/DELETE etc. 
		Test using LIVE endpoint 
	Intergration = allows soapui to import from and test sources/endpoints from third party application 
	Discover API = Select how you want to record HTTP/HTTPS traffic to web api 
		Records interactions on websites, testing buttons, links, movements
		
Before interact/create Test Suites, first experiment with your Services and APIs
	Goal is to Validate basic behavior
Creating New Project
	Definitions - Examines resource and automatically determines types to use
	EndPoint - Test live API with specific method
	Integration - Allows to test Third party APIs
	Discover API - records HTTP/HTTPS traffic to API. Uses external client applications or browsers record clicks and behaviors
		Like testing Web sites, interacts with buttons
Definition (commonly used for creating New Project with TYPE: Determine Automatically method)- it does JOB for you 

API gives ability to create Empty project and then user can bring any resources into it 
Endpoint Explorer - allows quick way to Test APIs with various methods, submit header, and receive Response all in one window
	You can also create Test Case right from Endpoint Explorer
# Payload - Data that needs included as Body (via JSON) - mainly used in POST, PUT, DELETE 
#Provides sample data automatically instead of question marks - when pulling WSLD file - From "Definition" from Create NEw Project
How does it knows which values to use as sample?
	Its getting all information from WSDL file, Data types, restrictions to decite what is permissible.
#REST, all it needs is Sample call (GET, PUT...)
#Soap request can validate WSDL fiel via FORM if its properly filled out with valid information.
#WSDL determines UI behavior for Web Service
#Soapui uses WSDL to determine how to configure requests
#Soap allows to Validate the REQUEST before submitting/Sending to Service or API 
#Soap mostly deals with *Web Services*
#Always good practice to have Positive & Negative Assertions

#Samples = API can provide sample data by goind to Settings -> WSDL -> Check box "Generate example values in new requests"
	Mainly used in SOAP, (it uses WSDL file to determine what data to fill in what fields)
#RAW tab in Request shows most recent requests that been called/Sent/Received on the wire


# TestSuites 

TestSuites are container of functional tests (TestCases)
TestSuites can be run sequentially or in parallel.

Two ways to run TestSuite = From Inside the product (useful when design & configure TestSuite) OR From Command Line (ideal for Automation & DevOps)
TestSuites can be automatically generated and can be implemented into different environment.

Tabs:    Test Case- overview of all TestCases in this TestSuite
		Transaction Log - Details about TestSuite execution
		Compare - Compare different testsuite runs
		History - view history for this testsuite
		Coverage - Measure thoroughness of TestSuite
		Requirements - Set requirements for this TestCase
		Step by step run - Debug this TestCase
		

#TestCase
-Have two main settings	- preferred unchecked  --- run test case completely, and then see exactly what failed 
	Abort test if an error occur - will halt the test if encounter a single problem 
	Fail TestCase if it has failed TestSteps - mark test case as Failure, even if one test case fails. (Keeps test case running even if fails)
Debugger lets you pause and analyze  your TestCase
TestCase is simply a functional test consists of at least one TestStep
	Each TestStep has specific purpose
TestCase can be debugged
TestCases can be easily turned into Load Test or Security Test
TestCases can be run in Groups or Standalone, they can be enabled/disabled 
# Debuggin Testcase
	Click Step by step run tab	
	SEt one or more breakpoints and run the test
	YOu may process entire testcase step by step (one teststep at a time)
	When finish debugging/analyzing, remove all breakpoints
#Test cases in TestSuite can be run Sequencially or in Parallel 
# Step by Step Run feature, lets you pause a TestCase and easily examine critical information 

# Debugger displays  (Step by step run tab)
	Global Properties
	Project Properties
	TestSuite Properties
	TestCase Properties
	SoapUI run Context
	Property expansions
You can filter what is shown, and expand/collapse entries

#TestStep - Introduction and Protocol

##Creating TestSteps##
	Assemble TestSteps in Right order
	Add Assertions
	Add Data
	
TestSteps Runs in sequence
Individual steps can be disabled
	Either Programmatically 
	Either User Interface
Develope a good functional TestCase and then choose the right component (TestSteps) for the job

#Categories: - Creating project
Protocol = communicate with a service/API = TestSteps (SOAP/REST/JDBC/JMS etc)
Flow Control = Determine how the TestCase will be processed - Flow/Structure of TestSteps/Properties
Data = Support input, output, data generation - Data Storage/Data Source

Protocol are TestSteps 
TestSteps consists of several different protocols	
	Communication - with service/API
	Flow Control - Determine how testcase will be processed
	Data - Input/Output, data generation/ Data driven tests 

Protocol: Responsible for transmitting and receiving messages to/from APIs
			Soapui automatically determines the right TestStep for API 
			Capable of transmitting & receiving headers (HTTP/Soap/JMS/JDBC)
			Capable to send/receive attachments
			Commonly evaluated by assertions
TestSteps:
	Soap Request = Use it to interact with Web service
	REST Request = Communicate with REST API using methods GET, POST, PUT ...
	JDBC Request = Interact with any database that has JDBC driver - Allows to write SQL
	JMS Request = Transmit a message to JMS message bus using either soap or rest protocol
	JMS - Java Messaging Service
	HTTP Request - Can be used to interact with any HTTP service including Websites & APIs
	AMF Request - Meant to work with Adobe Action Message Format (Action Message Format)
		binary format used to serialize object graphs such as ActionScript and XML or send messages between Adobe flash client and remote service
	XML-RPC - Communicate with this legacy protocol
		Remote procedure call protocl which uses XML to encode its calls and HTTP as a transport mechanism
	Publish using MQTT - Connect to MQTT broker and send message to it
	Drop MQTT Connection - simulate what should happen when MQTT connection unexpectedly drops
	Receive MQTT message - Subscribe to a topic on an MQTT broker and receive messages from it 
	SOAP VirtResponse - Create a soap virtual response and return it when request arrives
	REST VirtResponse - Create a REST virtrual response and return it when a request arrives
	
Protocol TestSteps interact with APIs
TestStep name states the targeted protocol
TestSteps can include Headers and attachments
Assertions are assigned to protocol TestSteps
Request and Response HTTP Headers are OFTEN different 
Message Viewer lets you see requests and responses

#HTTP Headers contain
	consists of case-insensitive name followed by : then value
	Holds response about locations, server provider
	May contain comments
	Connection/Authorization
	Proxy-Authentication
	WWW-Authentication 
	Exporations
	Cache control 
	Warnings
	Pragma
# There are four kinds of headers context:
	General Header: This type of headers applied on Request and Response headers both but with out affecting the database body.
	Request Header: This type of headers contains information about the fetched request by the client.
	Response Header: This type of headers contains the location of the source that has been requested by the client.
	Entity Header: This type of headers contains the information about the body of the resources like MIME type, Content-length.

#TestSteps - Flow Control 

Properties - Store variables within a functional test
Property transfer - Copy information within soapui (can be inserted automatically from Response)
Property wait - Pause TestCase execution until a property reaches a certain value
Send Mail - Generate and transmit an email message
Create File - Define and populate a file outside of the soapui environment
File Wait - Pause Testcase execution until a file is detected outside of soap
FTP - Uploads a file in passive mode to FTP server

ConditionGoto - Branch execution of a TestCase based on Boolean values
Delay Step - pauses a testcase for a specific number of milliseconds
Manual Step - Pauses a testcase indefinitely pending user interactions
Virt Runner - Launch or halt a virtual API
Run TestCase - Transfer control to another TestCase (Invokes other TestSteps)
Test Complete - Start an external project in SmartBear TestComplete product
Groovy Script - Execute groovy script within a TestCase (allows to add your own logic if SoapUI does not offers it)
	Enables Customer Scripting 
Assertion - Evaluate a collection of assertions using boolean logic

Multiple assertions allowe per TestStep
User can Group multiple Assertions in the Assertion TestStep


#TestStep - Data

TestStep = Protocol 
To make sure API services are ready for production, feed it with lots of realistic data

Data TestStep:
DataSource - Store data to be trasnmitted to an Api
DataSource Loop - Fetch the next record of API test data
DataSink - Save response or other data from Api
DataGen - Generate sample data from API calls

All DataSource need a DataSource Loop
Create random data using DataGenerator  DataSource
DataSink can export single property as well as Entire Response message


#Assertions - Intro & property content

Assertions is to test whether or not our product is meeting the customers criteria 
	It verifies expected behavior
	Determines if service has met certain criteria
	Lets user decide if test has passed or failed
Assertion Category:
	Property Content - verify if Response messages have certain information in them 
	Compliance, Status, and Standards - determine whether or not messages are properly structured and meet standards
	Script - Apply scripts to responses to meet our needs 
	JMS - determine if headers are present 
	JDBC - determine if headers are present 
	SLA - measure if Response comes back in proper amount of time (How fast is Response)
	Security - determine if services have any volnerabilities 
Useful to decide whether a test passes or fail
Can be placed into separete/own TestSteps
Determines whether service has met certain criteria
Not all assertions can be applied to type of protocol TestSteps
Assertions are to be assigned to any protocol oriented teststep

#Assertions 
Contains - making sure that certain value is present *anywhere* in the Response 
XPath Match - checks particular part of message in XML to see if value is present or not
	JSONPath Match is Exactly the same as XPath Match Assertion, just one is for XML and other for JSON 
JSONPath Count Match = Validates to Number of instances in response are present 
JSONPath Existence Match = Node and JSON response is present 
	(ex: timestamp = 12202020) - "timestamp" is Node/"12202020" is Value
JSONPath Match = Validates the Value for Node to match Value in Response
	User expects certain value will exist at a *particular* node in response 
Message Content Assertoins - checks for node (value) that is dynamic (changes) or Static (dont change) in the response 
	Lets user skip specific fields when evalueting a response
	Allows to validate specific nodes in XPath by selecting options to validate
	Validate multiple messages/Values
Equal = When you expect the response to exactly match the defined value (great for Text based info)
	Can compare entire response with predefined values
Equals (Binary) = great for evaluating multimedia service responses (ex: media, images, audio, video)

Xpath/JSONPath - evaluates specific node
Multiple content assertion can be processed
Message content - lets user skip specific fields when evaluating a response
Equals - compares entire Response with predefined value

Regular expression (regex) - a sequence of characters that define a search pattern. Usually such patterns are 
used by string-searching algorithms for "find" or "find and replace" operations 


#Assertions - Compliance & Standards

Valid HTTP status Code = validates proper code return (200, 404). Validates HEADER
Invalid HTTP status code = validates unwanted/error status code are present (400, 401, 402, 403, 404, 500, 501)

General purpose of compliance, status, and standards assertions 
	is IT is useful for REST apis, web services and other protocol

#These assertions are good for any situations regardless of Protocol
	Schema Compliance - tells if response from the web service matched its XML schema (web service)- Can also be used for REST
			Schema assertion sees if Web Service response matches its Contract 
			Schema assertion for Web service compares Response and WSDL 
	HTTP Download all resources
	Vaiid HTTP status codes
	Invalid HTTP status Codes
# Web Services assertions: only 
	SOAP Request
	SOAP Response
	SOAP Fault - checks for standard WEb Service errors
	Not SOAP Fault - confirms that no errors occurred
	WS-Security Status
	WS-Addressing Request 
	WS-Addressing Response - checks for routing headers
# Web Services are HEAVILY dependent on 
	Proper Schema
	Formatting
	Standardized response structures
# SOAPUI uses WSDL to determine how to configure request

Schema Complience = tells if response from the Web Service matched its XML Schema
	Validates response message to comply with associated WSDL or WADL schema definition (Used in REST too)
	schema compliance = If assertion failed, look at "WSDL Content" file itself (XML file)
	Validates SOAP Web Service response matching its Contract 
	Two things that Schema Compliance assertion compares is Response and WSDL 
	
SOAP Fault = Validates last received message is soap fault. Applicable only to Soap teststep
	Checks for Standard Web Service errors
	Produces Standardized error 
Not SOAP Fault = confirms that no errors occurred (WSDL or SOAP response returns NORMAL)
		It DOES NOT produce Standardized error 
Schema Assertion = Schema Compliance - Validates Response Structure 
	- Schema File contains (.xsd) extension
	- Everything about in Response is mentioned in Schema File (.xsd)
WS-Addressing - checks for routing headers
WS-Addressing checks to see if proper routing headers are in place 

#Assertions - Other

# Assertions can be CHANGED at Runtime
Service Level Agreement assertion (SLA) = Measures response time for call service (timing)(Applicable for ALL environment)
	Confirma how quickly results are returned
	5000 = 5 seconds
	10000 = 10 seconds
	500 = 500 miliseconds
	Used in Delay Test Step 
Sensitive Information Exposure = Security - validates no sensitive information is returned in Response 
	soapui Preferences includes library of global sensitive information that should not be visible to others
	Measures in Tokens
	Making sure its not returning any sensitive information 
	Sometimes Services will come under attack. SLA assertion will determine that if in case Services are attacked, 
		whether it reveals/expose sensative information.
	Ideally, when testing SLA assertion, we want SLA assertion return Zero/Blank, meaning no sensitive information exposed 
Script Assertion - if Assertion you need is not in readyapi build in, Script allows to build custom assertions
	Must include Boolean true or false value
	Groovy Script must evaluate to a Boolean Value
	Whenever script validates, it will process as an assertion
Assertion TestStep = allows to apply assertions to individual teststeps (Combines assertions)
	Allows to apply assertions to REQUEST 
	AND/OR Boolean Conditions are allowed to be used in this assertion teststep
	Assertions can be combined into Groups using "Assertion TestStep"
# JDBC and JMS Assertions both check that relevant headers and status codes are received

JSM Assertion:	determines if there is any Status or Timeout issues when interacting with message busses
	JMS Status
	JMS Timeout 
JDBC Assertions: determines if there is any Status or Timeout issues. If operations has timed out. 
	JDBC Status
	JDBC Timeout 

HTTP Header Equals - Validates Header assertion. Validates the value its expecting from Header
HTTP Header Exists   - Value in Header object might change like Date, Time. This validates that Value in Header Object actually exist in Header


#Data-Driven Testing

Test with Real Data
	Better to use realistic data to exercise data issue that can happen in production
		Using same data over and over - its same as using same exact step in every scenario/ Must be dynamic 
		If used Variety of Data, you can see dynamic performance and how program reacts to different data 
		Using same data risks of data using Cached results therefore can give false results 
	Measure realistic performance
	Determine database delays (latency)
	Properly exercise business logic - when using variety of data, you can see distinct performance and bugs
	Using same amount of data, over and over, may result in giving cached results which could be wrong results
DataSource Types:
	Grid = Simple in-lined row and column-based datasource - Create in-lined test data
		Great for quick testing but not for extensive usage
	File = Meant for plain text files (CSV, TXT)
		Individual Properties or entire message from file can be extracted
		File can contain JSON or XML and used as fields
	Excel = uses speardsheet to store test information
		Worksheet and starting cell can be specified for use
		Usually first row is skipped cuz its a title
	Directory = Transmit a directory of files to API, one by one
		Meaning, Folder containing many excel or other type files with Data info to Test 
		Requires creating a property to hold file contents
		Great for regression testing
	Data Connection/JDBC = interacts with database
		Ideal for VERY large Data Set
		Can create properties for you in DataSource
		SQL knowledge is required
	Groovy = Enables data generation directly from script
		Meant for situations of highly specific, often-dynamic requirements
		If no needed Data Type found, Scripting would be best bet
	JSON = Designed for taking JSON output from one API call and feeding it into another
		Same option as for Property Transfer
	Data Generator = Creates randomized data  - can be on the fly
		Lets you create Test Data within soapui itself
		Allows to combine data with generated values

Data-Driven Testing requires data and defined properties from DataSource which combines with DataSource Loop
	Requires defining properties
JDBC drivers enable RDBMS connections
Property names can be created automatically from relational database
Create in-lined test data with Grid DataSource
Data Generator can create random test input for you

#DataSink Types:
	Data Connection & JDBC - Save Information to a database
	Excel - Output data to a spreadsheet
	File - Store Test Data in a flat file (like txt)
	Property - Place information into a property
	SubReport - Feed Data to a reports
	Groovy - Provide information as input to a script
#Data Focused TestSteps: WorkFlow
	DataSource
	DataSink (optional)
	DataSource Loop
	DataGen (superseeded by DataSource)
	
	
#Virtual Services

Sometimes user can't connect to a service to test it. OR Service hasn't been written yet, OR service has bugs but can't quiet test yet
^ This is why you need Virtual Services. 
It lets you build robust tests
It create mock service

#Once Mock Services are defined (created), JETTY will deploy it (JETTY is intalled behind it)
	Requirement for SOAP - all needed is WSDL file
	Requirement for REST - all need is Sample Call (endpoint)

# Before, earlier SOAPUI Pro 5.1.2 - it was called Mock Service, NOW its called Service V 
#Mock Services and Responses
Mock service response are completely configurable
Responses are usually hard coded. NO matter how many times you send request with different data,
	youll get same response.
	It can Write Scripts to make it more dynamic
Responses can be completely generated during runtime
Responses can be defined for given operation
	Many/Multiple responses can be created

#Routing Options
	Script / Sequence / Query_match / Xpath / RANDOM
#Scripting and Mock Services
	There are several places to where you can write scripts for mock services
		Start script / Stop Script / OnRequest Script / AfterRequest Script / Inline script
#Deploy Mock Services
	On your own computer
	On a shared server
	Users can connect to YOUR mock service even if its on your PC, As long as the port is open for access
#Invoking Mock Service
	To call mock service, you need endpoint
	Multiple users can work with single Mock Service
	Mock service can tell you which user invoking it
	
#ServiceV - Setup
	Covers both Soap and Rest services
	Incoming messages and outgoing responses
	YOu can configure how responses can be dispached - Script / Sequence / Query_match / Xpath / RANDOM
	You can define response content, write scripts, configure datasources, and write assertions 
#ServiceV - Behavior - config 
	ability to fine to latency, hardware capacity, threading profile, bandwith
	Define error responses to match expected verses Responded
#ServiceV - Transaction Log
	It keeps all incoming and outgoing messages
#ServiceV - DataSources
	Make it possible to assemble responses using virtual limitless set of data taking from spreadsheets, files, databases
#ServiceV - Coverage
	Works for Web Services 
	Determines how thoroughly incoming requests sent outgoing responses are covering the services WSDL contract
Virtual Services can be created for SOAP and REST
Jetty engine runs virtual services
Multiple virtual reponses can be defined
Virtual services may be deployed to central site
Scripting lets you create extensive business logic for virtual services


#Security

# Soapui support these technieques:
HTTPS
HTTPS with Client Authentication
WS-Security UsernameToken
WS-Security TimeStamp
WS-Security XML Encryption
WS-Security XML Digital Signature
SAML

#Soapui security wizard contain build in attacks. 
	Designed to cause service to Crash
	Designed to return details about its implementations for more targeted attacks
	 or Both 
	 My job is to find volnurable spots and Alert Development team to fix the gaps
#Security Wizard has two main tests categories
	(1)Tests that sends damaged or confusing information to your service
		Communicating wrong data types
		Going beyond normal boudaries for information (such as sending Big numbers to elements expecting Small numbers)
		Transmitting enormous as well as Damaged XML documents
		Sending Randomized data to your service
		
	(2)Tests that attempt to run service-side code
		Attempt to run SQL/Xpath or other scripts 
Good Security strategy would include both of these (1 and 2)

#Security Tests
	Invalid types = send the wrong type of information
	XPath Injection = Attempt to execute server-side XPath
	Boundary Scan = Test Corner Conditions
	SQL Injection = Attempt to execute server-side SQL
	XML Bomb = Submit a massive XML document
	Malformed XML = Send in corrupted XML
	Malicious Attachment = UPload a virus or executable
	Cross Site Scripting = Test for exposed message parameters
	Fuzzing Scan = Embed random data in valid messages
#Assertions and Security
	Default Assertions
	- Sensitive Information Exposure 
	- Schema Compliance
But you can apply all assertions to Security Scan 
	However, not all assertions could be relevant to security

#Best Practice for Security 
- Start Small: one operation at a time, with few parameters
	- One scan at a time: Boundary conditions is great first scan
	- One Assertion at a time: Sensitive Information Exposure is CRITICAL
	- Dont let soapui automatically generate your scans
Security scans can be created from TestCases


# Groovy

Supports object-oriented and script-style programming
Supports GUI development
Integrates with Java libraries

Resources to Learn Groovy:
	groovy.codehaus.org
	https://www.soapui.org/apidocs/overview=summary.html - about soapui api
	Groovy can do anything
Groovy is like Java but with numerous improvements
Groovy is the mainly scripting language for Api
Groovy scripting is available throughout the environment
Now, these days, Groovy is becoming less necessary 


# Refactoring

Refactoring means keep messaging and schema up to date. It helps to Manage Changes.
	New Elements introduced
	Old Elements has been removed
	Renaming operations/Projects

Sometimes Web services change so Refactoring is introduced. 
#Reloading vs Refactoring WSLD
- Reloading brings fresh copy of WSDL - SImply reload WSDL if no changes been made
	- "Update Definition" is a menu option (same as reload) - Right-click on Project
- Refactoring brings fresh copy AND lets you update all affected objects in a project
		If file/WSDL has changes/changes been made, Refactoring is way to do it (Reload)
		You can Refactor messages, schema, XPath 
		Refactoring requires NEW version of WSDL file 
	- "Refactor Definition" is a menu option	
			- It detects when messages have Changed/Renamed/Added/Removed
			- May need to work with Developers to understand changes in WSDL
			- Before Replacing/Refactoring Definition - work with Devs to be sure its Correct File Name
			

# Monitoring

Monitoring helps better understand of Live APIs
It can help user guide to find tune your strategies
Acquire realistic data to drive future tests
Make sure when test is running, all APIs are working properly
Provides great visibility to operator when program is running
Monitoring can also be applied in production

# Monitoring embeded with several programs:
	HTTP Monitoring	
	Apache TcpMon
	AlertSite - mainlhy for production purposes (applied in production)(For Websites)
			It can monitor api's availability/accuracy/Performance - 24/7 in production 
	
# HTTP Monitor can listen and capture traffic To/From Api (between Client and Server)
	- Works even in VIRTUAL API (even if both on your computer)
	- mainly used by API testers
	- it can monitor these protocols: (covers pretty much every type of protocol)
			HTML
			Soap
			Javascript
			XML
			JSON
			AMF
HTTP monitor can be easy setup - requirements:
	- Proxy must be configured properly (Set to Manual Proxy from Preferences settings)
			- Set Proxy to Manual
			- Set Port to 8081 or some other
			- Launch HTTP Monitor from menu
			- Make sure Ports are matching
			- Set check for Set as Global Proxy 
			- When done, HTTP Monitoring will be running in background, waiting for project to start execuring
			- When done with Monitoring, Set Proxy back to "None" or its previous setting 
			
	- SoapUI NG PRO is running along HTTP Monitor 
			Message traffic can be created inside the WebSite server or on SOAPUI
# Great thing about HTTP Monitoring on Live system:
	YOu can quickly gather huge collection of actual production request and responses 
	They can form the basis of test data for future quality assurance 
# Http monitoring is for developing and testing
# Captured messages can be used for Test Data
# Responses can be added to Virtual API
# Remember to turn Proxy Off (prvious config or to NONE) when done with HTTP Monitoring 


# Reporting

API offers several different report types:
	JUnit-Style Report  - Outputs to HTML
	Data Export --- Can be imported into Other tools
	Jaspersoft Report  - include in SoapUI pro, also in print version 
		Jasper creates rich high detailed report, use any layout you like 
4 ways of reporting:
	Printable reports
	Data Export
	JUnit-style HTML reports
	Allure report
Reports can be launched from different levels:
	Project
	TestSuite
	TestCase
	LoadTest

Reports can be customized from File -> Preference -> SoapUI PRO setting 
Reports stored in three possible places:
	In Project file	
	On File system
		- $soap_home/bin/reports
		- $soap_home/bin/subreports
	
Reports can be run from command line or within product
	Advantage of launching reports from command line : Tie-in with automation build scripts
Reporting is GOAL of Effective Testing
Reporting keeps everyone UP-to-Date: Development, QA, User
	Provides easy undertand format
SoapUI provides helpful colorded report
	It records in detail, exact reasons for failed TestSteps
# Jasper reports can be extensively customized and available for Print
# You may configure reports to provide comprehensive error detail
# Data exports can populate external reporting tools (excel, crystal, etc.)
# Jasper reports can be configurable with XML



------------------	
UDEMY - Learn API & WebService Testing
------------------
# 3 Layers
Front End - (GUI, Presentable Screen/Layer)- JavaScript, CSS, JAVA
Business Logic - (API-Application Programming Interface) - Java, C#, C++, Phyton
Back End - (Database)- My SQL, SQL, Oracle

# APIs are in form of JAVA files (also available in WebService)
	- No need URL
	- No need Web Browser
	- API is in form of JAVA (no need internet, can be tested locally)
# Web Service
	- Reads XML format
	- Available in WebServers
# API is NOT a WebService BUT WebService can be API 
------------
Web Services
------------
1. SOAP - XML,  WSLD file
2. REST - XML, JSON, HTTPS, HTML, (GET, POST etc...) Must have URL Request 
-----------
Web Service is service available over Web or Network, it communicates between 2 machines/Applications
----------------------------------------------
# Web Application - Provides service directly to User - Receives response from Web Server
# Web Service - Provides service to other Programs

# Components of Web Services
	WSDL - Web Service Description Language. 
		- XML based-language that describes  Web Services, how to access and locate them
	UDDI - Universal Description Discovery and Intergration
		- Open internet-based specification, offers directory service for storing information about Web Services
		- Company or Storage Unit where Service Providers store their Services
			- UDDI - Place where ALL Services are Stored/Available 
		- With WSDL - Web Services can be accessed and located
		- ##Service Consumer (Client) uses WSDL to Get/Find Services from UDDI, then WSDL Approves the Service and Client Sends Request to Server
# These are Service Providers - Web Service - Servers - Store their services in UDDI
# These are Service Consumers - Clients - They only send Request and get Response
	- UDDI - Place where Service Cunsumers Finds Service
	- WebService stored in UDDI

### Web Service vs API ###
	WebService ALWAYS need network to operate/Test.BUT API may not need Network to operate/Test
		API can be tested on local machine if Server is located Locally
	WebService can be used by Soap, Rest, XML RPC BUT API can be communicated through other ways like CURL calls/URL
	API can be considered as Web Service BUT ALL Web Service are not API 
	API can be exposed in number of ways like via JAR, DLL files, XML over HTTP, JSON over HTTP - which may not need network

### SOAP vs REST ###	
# SOAP - Simple Object Access Protocol
	- Soap is a Protocol 
	- designed to ensure that programs built on different platforms and programming languages could exchange data easily
	- exchanges messages between applications/systems
	- it uses HTTP protocol to transfer XML messages 
	- Supports XML for data exchange (Request and Response)
	- Heavy Weight cuz it uses WSDL file, also very Slow 
	- WSDL - Web Service definition Language - written in XML format
	- It is VERY Strict for its Standard Rules	
	- Requires MORE bandwidth and resource
	- Defines its own Security
	
# REST - Representational State Transfer 
	- REST is an architectural style
	- designed specifically working with components such as media components, files, objects on a particular hardware device. 
	- Any web service that is defined on the principles of REST can be called RestFul web Service.
	- It uses HTTP verbs/protocol = GET, POST, PUT, etc... to work with required components
	- Uses mostly HTTP rather than HTTPS - cuz HTTPS is more enctypted, not fur user eyes, but HTTP is easier to aquire info 
		- Allow users to view web pages, easily to communicate between different systems. 
	- HTTP disadvantage - Information flows between server to browser can be easily stolen. 
	- HTTPS uses SSL (Secure Sockets Layer) certificate which helps to secure encrypted connection between server and browser. 
	- REST does not define too much standard unlike SOAP 
	- Requires LESS bandwidth and resource
	
# Advantages of REST over Soap
	REST supports multiple format to exchange data between 2 machines/Application
	REST services are faster than SOAP 
	Less data transfer between machines 
	SOAP is protocol, REST is set of guidelines which described how client should interact with server
	SOAP can be accessed thru WSDL only BUT REST can be accessed thru WADL or URI
	
----------------------------------------
# Tools available to use for API
	API - no internet required, can be tested locally (available in Jars file)
	WebServices - Requires Internet, test by sending HTTP request (URL)
	Soapui
	POSTMAN
	Katalon - Testing Web Services
	Assertible
	Apigee
	Apache JMeter - performance testing
	REST-Assured - complete Automation
	Tricentis
	Karate
--------------------------------
# API/Web Service Testing Process
	- API Specification Review - review API specifications, documentation from test perspective
	- Test Specificaton Development - document deals with test conditions and expected results 
	- Test Framework Development - choose tools to use, JMeter, SOAPUI, REST, other resources
	- Test Case Development - code/create test cases
	- Test Execution and Report to Dev or Client

# URI and URL (Uniform Resource Identifier vs Uniform Resource Locator)
URL Link contains of: 
	Domain: www.michaelcropper.com/
	URI: /seo-tools/uri-encoder-decoder-tools-for-seo?
	Query String: name=value&lastName=value&Address=value
# Part of URL = Domain + URI + Query String

Domain: Physical server where website is hosted
URI: Identifier which maps to file on your server - Directory/Folder/ Where that folder/File is Located inside Server
Query String: Part of GET, POST, PUT request to pass in values to customise output (Parameters)
-----------------------------------------
# HTTP Request Contains
 URI
 HEADER
 Payload - Data in JSON, XML format (Data send or received)
	ex: POST - create FirstName, LastName, Address, Location - includes in Payload

# HTTP Response Contains
 Status Code - 200 OK
 Response Payload
 String Message "Successfull"
 
Example: 
POST Call: via JSON, XML or other form
AccountID=1
AccountName="TOM"
Address="London"

GET Call: URL -> http://api/service/account/1
Parameters
Query Parameters
HEADER

# Status Codes (Http code): 
200 --------> (OK)GET Successfull
201 --------> (Created) POST Successfull
202 --------> (Accepted)POST Data Accepted 
200/201 ----> PUT Successfull (201 - in case new Resource created)
204/200 ----> DELETE Successfull
204 --------> No Content (You(PUT-Update) Date to server but there is no Data to Return. Must use GET)

400(s) Code means Something wrong with Data (input), Data might have changed by Devs, May need to check with Devs 
400 - Bad Request -------------- Invalid Request 
401 - UnAuthorized ------------- Request did not include Authentication token/or Token was expired
403 - Forbidden ---------------- Client do NOT have permission to access resource
404 - Not Found ---------------- Requested resource NOT found
405 - Method NOT Allowed ------- HTTP Method not Supported 
409 - Conflict

500 - Internal Server Error ----- 500(s) Code means Something Wrong with Server
502 - Bad Gateway
503 - Service Unavailable
504 - Gate Timeout

# Method7
	HEAD - Fetch (GET) only HEADER & BODY data from the application
		Header includes - Data time, format, encryption and more...
	OPTIONS - Finds which REQUESTS METHODS  server supports 
		(In RESPONSE, you'll get this: Allow: OPTIONS, GET, HEAD, POST...)
		When you get URL, you want to know which METHODS that URL supports 
	TRACE - Used for Debugging. This method will Loop - Back, meaning return same message as in REQUEST 
--------------------------------------------------------------------
Jetty is a Web Server, similar to Tomcat server, made for Web Applications, Web sites
	Java HTTP Web server and Java Servlet Container
	Jetty is a Servlet container and Web Server which is known to be portable, lightweight, robust, flexible, easy to integrate
	Jetty can be deployed as a standalone server and also can be embedded in an existing application.
Jasper Soft - Creates Advanced/Detailed Report. Allows user to Customize in any form or shape, Convert into PDF file and Share with steakholders. 
	Works and follows the guidelines of REST method. 
Saxon - collection of tools for processing XML documents. Main Component is XSLT processor. 
	Saxon offers XQuery extension, also, XML Schema, XPath
	Use Saxon API calls to navigate directly to other nodes in the document, either directly, or using XPath expressions
	Saxon can also be used as Java Library without making XSLT stylesheets.
	
Hermes - Hermes has implemented web services to communicate with external applications. 
	Advantage of using WEB SERVICES are to reduce coupling between external applications and Hermes - 
	And to allow external applications to integrate Hermes seamlessly using any programming languages that support sending SOAP Messages
	Hermes - interacts with message bus - requires proper setting for endpoint
	HermesJMS makes possible to send and receive messages to and from JMS queues
----------------------------------------------------------------
# Query VS Path Parameter Resource (both GET)

(URI)
Path Parameter - used to identity a specific resource or resources - To identify specific customer, User will use "CustomerID" 
	ex: GET hhtp://localhost:8899/mysql/customers/456574856 - specific customerID number
Query Parameter - used to sort/filter those resources 
	ex: GET http://localhost:8899/mysql/customers?country=London - Filtering out customers from London
		"Country" = Key
		"London" = Value       After ? it is Parameters 
		Query Parameters in Results - usually includes [] - as an Array 
---------------------------------------------------------------------
Event Handlers
